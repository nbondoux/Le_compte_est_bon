module Main where 

import IO
import System
import Char
import List

data CompListT a = CompListEnd | CompList a  (() -> (CompListT a))

compListMap lst f = 
  case lst of
    CompList res next -> CompList (f res) (
      \() ->  compListMap (next ()) f)
    CompListEnd -> CompListEnd


compListMerge map1 nmap2 =
    case map1 of
      CompList res next -> CompList res  (
        \() -> compListMerge (next()) nmap2)
      CompListEnd -> nmap2()

compListFoldLeft a lst f =
  case lst of
    CompList res next -> compListFoldLeft (f a res) (next()) f
    CompListEnd -> a
{- compListLift :: CompListT (() -> CompListT a) -> CompListT a -}
compListLift lst =
  case lst of
    CompListEnd -> CompListEnd
    CompList l next -> 
      case l() of 
        CompList l2 next2  -> CompList l2 (
          \() -> compListLift (CompList next2 next))
        CompListEnd -> compListLift (next())

{-
this method is built on this model:
let rec myLift lst = 
  match lst with
      [] -> []
    |l::next -> ( 
      match l with
          l2::next2 -> l2::(myLift (next2::next))   
        |[] -> myLift next
    );;
 -}

{-
  Concept of this algorithm:
  The value generated (all extracted combinations of numbers by the 4
  operations) from a list l (size L) are the values made of N numbers
  generated by each of its  sublists of size N + the values made of
  combinations by an operation of the values generated by the couple of lists
  whose combined total number of elements is L
  no duplicate value is therefore ever generated for l or any other sub-lists
-}


{- return a compList holding all possible l1 where
   l1 is made of iL1Size elements of iL
-}

getSubCombinationsFixedLSize iL iL1Size iLSize =
  if iL1Size == 0 then
    CompList [] (\() -> CompListEnd)
  else
    case iL of 
      h:t ->  
        let listsWithH = compListMap (getSubCombinationsFixedLSize t (iL1Size - 1) (iLSize -1 )) (\l -> h:l) in
        if iL1Size < iLSize then
          compListMerge listsWithH (\() -> (getSubCombinationsFixedLSize t (iL1Size) (iLSize - 1)))
        else
          listsWithH
      [] -> CompListEnd

  
{-  return a compList holding all possible l1 where l1 is made n elements of iL,
    iMinSize <= n < iMaxSize
    l1 are returned by growing order of n
-}

getSubCombinations iL iLSize iMinSize iMaxSize =
  let getSubCombinations_rec n =
        if n >= iMaxSize then
          CompListEnd
        else
          compListMerge (getSubCombinationsFixedLSize iL n iLSize) 
          (\() -> getSubCombinations_rec (n+1))
  in
   getSubCombinations_rec iMinSize;;
        
{- return a compList holding all possible couple (l1,l2) where
    l1 is made of iL1Size elements of iL and l2 contains the complementary elmts
    of iL
 -}

getSubCombinationCouplesFixedL1Size iL iL1Size iLSize =
  if iL1Size == 0 then
    CompList ([],iL) (\() -> CompListEnd)
  else
    case iL of
      h:t ->
        let hInFirsts = compListMap 
                        (getSubCombinationCouplesFixedL1Size t (iL1Size - 1) (iLSize -1 ))
                        (\(l1,l2) -> (h:l1,l2)) in
        if iL1Size < iLSize then
          let hInSeconds = \() -> 
                compListMap
                (getSubCombinationCouplesFixedL1Size t (iL1Size)
                 (iLSize - 1)) (\(l1,l2) -> (l1, h:l2)) in
          compListMerge hInFirsts hInSeconds 
        else
          hInFirsts
          
      [] -> CompListEnd

{- return all non_ordered subcombinations of iL where iL1 has size
   iL1Size; it differs from getSubCombinationCouplesFixedL1Size, as
   if iL1Size*2 == iLSize, we must not return (['a'],['b'])  and (['b'],['a'])
-}

getSubCombinationCouplesFixedL1Size_bis iL iL1Size iLSize =
  if iL1Size * 2 /= iLSize then
    getSubCombinationCouplesFixedL1Size iL iL1Size iLSize 
  else
    case iL of
      h:t -> compListMap
             (getSubCombinationCouplesFixedL1Size t (iL1Size-1) (iLSize-1))
             (\(l1,l2) -> (h:l1,l2))
      [] -> CompList ([],[]) (\() -> CompListEnd)


{- returns all non-ordered couple of sub combinations of l!!! -}
getAllSubCombinationCouples iL iLSize =
  let f i =
        if i *2 <= iLSize then
          compListMerge (getSubCombinationCouplesFixedL1Size_bis 
                         iL i iLSize)
          (\() ->f (i+1))
        else
          CompListEnd in
  f 0;;


data Operation = Add|Minus|Mult|Divi deriving (Eq)
data Tree = Number Int | Node Int Tree Tree Operation

instance Show Operation where 
    show Add = "+"
    show Minus = "-"
    show Mult = "*"
    show Divi = "/"

op_priority_op Add = 1
op_priority_op Minus = 1
op_priority_op Mult = 2
op_priority_op Divi = 2

op_priority_node  (Node _ _ _ op) = op_priority_op op
op_priority_node  (Number _) = 100

value_node (Node v _ _ _)  = v
value_node (Number v) = v

is_operation_associative Add = True
is_operation_associative Mult = True
is_operation_associative Minus = False
is_operation_associative Divi = False


instance Show Tree where 
  show (Node _ nl nr op) =          
    let strLeft = show nl in
    let strRight = show nr in
    let strLeft2 =
          if op_priority_node nl < op_priority_op op then
            "("++strLeft++")"
          else
            strLeft in
    let strRight2 = 
          if ((not (is_operation_associative op) ) &&
              op_priority_node nr <= op_priority_op op) ||
             op_priority_node nr < op_priority_op op then
            "("++strRight++")"
          else
            strRight in
    strLeft2++(show op)++strRight2

  show (Number i) = show i;;

{- future parameter represents the computation to be appended at the end of the
   computed CompList;
-}

algo_l_size iL iLSize future =
  case iL of
    [a] -> CompList a (\() -> future())
    [] -> future()
    _ ->
      let f_listCouples iListCoupleList =
            case iListCoupleList of
              CompList (l1,l2) nextCouple ->
                let l1_size = List.length l1 in
                let l2_size = List.length l2 in
                let f_subcombs1 iListCombs1 =
                      case iListCombs1 of
                        CompList elmt1 nextComb1 ->
                          let val1 = value_node elmt1 in
                          let f_subcombs2 iListCombs2 =
                                case iListCombs2 of
                                  CompList elmt2 nextComb2 ->
                                    let val2 = value_node elmt2 in
                                    let node_is_op n op =
                                          case n of                          
                                            Node _ _ _ op2 -> op==op2
                                            _ -> False in
                                    let nextop4 () =
                                          let nextToUpper =
                                                (\() -> f_subcombs2 (nextComb2())) in
                                          if val2 > val1 && val1 > 1 && (val2 `mod` val1) == 0 then
                                            CompList
                                            (Node (val2 `div` val1) elmt2 elmt1 Divi)
                                            nextToUpper
                                          else
                                            if  val1 >= val2 && val2 > 1 && (val1 `mod` val2) == 0 then
                                              CompList
                                              (Node (val1 `div` val2) elmt1 elmt2 Divi)
                                              nextToUpper
                                            else
                                              nextToUpper() in
                                    let nextop3 () =
                                          if val1 > 1 && val2 >1 &&
                                             not (node_is_op elmt1 Divi) &&
                                             not (node_is_op elmt2 Divi) then
                                            CompList
                                            (Node (val1 * val2) elmt1 elmt2 Mult)
                                            (\() -> nextop4())
                                          else
                                            nextop4() in
                                    let nextop2 () =
                                          if (val2 > val1) && val1 > 0 then
                                            CompList
                                            (Node (val2 - val1) elmt2 elmt1 Minus)
                                            (\() -> nextop3())
                                          else if (val1 >= val2) && val2 > 0 then
                                                 CompList 
                                                 (Node (val1 - val2) elmt2 elmt1 Minus)
                                                 (\() -> nextop3())
                                               else
                                                 nextop3() in
                                    let nextop1 () =
                                          if val1 > 0 && val2 >0 &&
                                             not (node_is_op elmt1 Minus) &&
                                             not (node_is_op elmt2 Minus) then
                                            CompList                          
                                            (Node (val1 + val2) elmt1 elmt2 Add)
                                            (\() -> nextop2())
                                          else
                                            nextop2() in
                                    nextop1()                  
                                  CompListEnd -> f_subcombs1 (nextComb1 ()) in
                          f_subcombs2 (algo_l_size l2 l2_size (\() -> CompListEnd))
                        CompListEnd -> f_listCouples (nextCouple()) in
                f_subcombs1 (algo_l_size l1 l1_size (\() -> CompListEnd))
              CompListEnd -> future() in
      f_listCouples (getAllSubCombinationCouples iL (List.length iL))


algo_all_sizes iL iLSize =
  {-this "algo" calls are used for the 
      "the values made of N numbers generated by each of its sublists
      of size N" part of the algorithm described on top of the file
    
      
      gets all combinations of size n verifying iMinLength <= n < iLSize
    -}
  let subLists = getSubCombinations iL iLSize 1 (iLSize+1) in
  let f_sublists iSL =
        case iSL of
          CompList sl nextsls ->
            algo_l_size sl (List.length sl) (\() -> f_sublists (nextsls()))
          CompListEnd -> CompListEnd in
  f_sublists subLists


{-
le_compte_est_bon liste cible =
    showSolutions (algo_main (construct_arbre liste) cible) where
        showSolutions ((sol,pr_sol):l) =
            do
              putStr (show cible)
              putStr (" = "++(show sol)++" ; "++(show pr_sol)++"\n")
              showSolutions l
        showSolutions [] =
            do
              putStr "No better solution\n"
-}

le_compte_est_bon iL iTarget =
  let computations = 
        algo_all_sizes (List.map (\x -> Number x) iL) (List.length iL) in
  let rec_algo iComps iBest =
        case iComps of
          CompList n next ->
            let val_n = (value_node n) in
            let isNewBest =
                  case iBest of
                    (Just (iB,delta)) ->
                      (iTarget - val_n < delta && val_n - iTarget < delta)
                    Nothing -> True in 
            do
              newBest <-
                if isNewBest then do
                  putStr ("Best so far: "++(show val_n)++" = "++(show n)++"\n")
                  let new_delta =
                        if val_n >= iTarget then
                          val_n - iTarget
                        else
                          iTarget - val_n in
                    return (Just (n,new_delta))

                else
                  return iBest

              (
                if (val_n == iTarget) then
                  return (Just n,newBest)
                else
                  rec_algo (next()) newBest
                )
          CompListEnd -> return (Nothing,iBest) in
  do
    res <- rec_algo computations Nothing
    (let line =
           case res of
             (Nothing,Nothing) -> "No Solution"
             (Nothing,Just (best,_)) -> "No Solution; nearest solution is: "++( show (value_node best))++" = "++(show best)++"\n"
             (Just n,_) -> (show (value_node n))++" = "++(show n)
     in
      putStr line
      )
    return res


message_help iProgName =
    do
      putStr (iProgName++" number1 [number 2 [number 3 ...]] target\n")


main=
    do
      args <- getArgs
      progName <- getProgName
      let longueur = (List.length args)
      if (longueur <2 || (List.elem "-h" args) || (List.elem "--help" args)) then 
          message_help progName
       else 
           let intArgs = List.map (\x  -> let i = read x in 
                                    if i < 0 then 
                                      error ("Error: Input "++(show i)++" < 0") 
                                    else 
                                      i
                                  )                         
                         args in
           do
             le_compte_est_bon (List.take (longueur -1) intArgs) (List.last intArgs)
             return ()
           