#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

// a simple functor
struct NB_BaseFunctor {
  void (*run) (struct NB_BaseFunctor*, void *);   
};
typedef struct NB_BaseFunctor NB_BaseFunctor_t;



// generics for stack-less coroutines

// based on the idea from Simon Tatham: http://www.linuxhowtos.org/C_C++/coroutines.htm

#define crBegin switch(((NB_BaseSLCoroutineCtx_t*) ioCoroCtx) -> line) { case 0:
#define crReturn(x) do { ((NB_BaseSLCoroutineCtx_t*) ioCoroCtx) -> line=__LINE__; return x; \
                         case __LINE__:; } while (0)
#define crFinish }


// the context of a stack-less co-routine
struct NB_BaseSLCoroutineCtx;

// a Holder wich maintains a list of contextes of coroutines of a same kind (it  links the head of a linked list)
struct NB_BaseSLCoroutineCtxHolder;

struct NB_BaseSLCoroutineCtxHolder {
  // should also hold mutexes for updates
  struct NB_BaseSLCoroutineCtx * poolHeadOfList;
  struct NB_BaseSLCoroutineCtx * freePoolHeadOfList;
  
  size_t ctxSize;

  NB_BaseFunctor_t* elmtConstructor;
  NB_BaseFunctor_t* elmtDestructor;
};
  

struct NB_BaseSLCoroutineCtx {
  struct NB_BaseSLCoroutineCtx* nextFree;
  struct NB_BaseSLCoroutineCtx* next;
  struct NB_BaseSLCoroutineCtxHolder* pool;

  unsigned int line; 
};

typedef struct NB_BaseSLCoroutineCtx NB_BaseSLCoroutineCtx_t;
typedef struct NB_BaseSLCoroutineCtxHolder NB_BaseSLCoroutineCtxHolder_t;

inline void NB_freeSLCoroutineCtx (NB_BaseSLCoroutineCtx_t* iCorCtx) {
    // should lock a mutex here
    iCorCtx -> nextFree = iCorCtx -> pool -> freePoolHeadOfList;
    iCorCtx -> pool -> freePoolHeadOfList = iCorCtx;
}


NB_BaseSLCoroutineCtx_t* NB_getSLCoroutine (NB_BaseSLCoroutineCtxHolder_t* ioSLCoroCtxPool) {
  NB_BaseSLCoroutineCtx_t* coro;
  if (ioSLCoroCtxPool -> freePoolHeadOfList != NULL) {
    coro = ioSLCoroCtxPool -> freePoolHeadOfList;
    ioSLCoroCtxPool -> freePoolHeadOfList = coro -> nextFree;
  } else {
    coro = (NB_BaseSLCoroutineCtx_t*) calloc (1,ioSLCoroCtxPool -> ctxSize);
 
    // should lock by mutex here
    coro -> next = ioSLCoroCtxPool -> poolHeadOfList;
    ioSLCoroCtxPool -> poolHeadOfList = coro;

    coro -> pool = ioSLCoroCtxPool;

    if (ioSLCoroCtxPool -> elmtConstructor != NULL) {
      ioSLCoroCtxPool -> elmtConstructor -> run (ioSLCoroCtxPool->elmtConstructor,coro);
    }
  }
  coro -> line = 0;
  return coro;
}


void NB_freeSLCoroutineCtxPool (NB_BaseSLCoroutineCtxHolder_t* ioSLCoroCtxPool)
{
  // should lock by mutex here ?
  NB_BaseSLCoroutineCtx_t* coro = ioSLCoroCtxPool -> poolHeadOfList;

  while (coro != NULL) {
    NB_BaseSLCoroutineCtx_t* nextCoro = coro -> next;

    if (ioSLCoroCtxPool -> elmtDestructor) {
      ioSLCoroCtxPool -> elmtDestructor -> run (ioSLCoroCtxPool->elmtDestructor,coro);
    }
    free (coro);
    coro = nextCoro;
  }

  // should lock by mutex here
  ioSLCoroCtxPool -> poolHeadOfList = NULL;
  ioSLCoroCtxPool -> freePoolHeadOfList = NULL;
}

// end of generics for stack-less coroutines



// Concept of this algorithm:
// The value generated (all extracted combinations of numbers by the 4
// operations) from a list l (size L) are the values made of N numbers
// generated by each of its  sublists of size N + the values made of
// combinations by an operation of the values generated by the couple of lists
// whose combined total number of elements is L
// no duplicate value is therefore ever generated for l or any other sub-lists




// ////////////////////////////////////////////////////////////////////////////
// simple sub-lists generator
// ////////////////////////////////////////////////////////////////////////////

static NB_BaseSLCoroutineCtxHolder_t SubCombinationsGeneratorRecCtxHolder = {0,};
static NB_BaseSLCoroutineCtxHolder_t SubCombinationsGeneratorCtxHolder = {0,};


struct SubCombinationsGeneratorRecCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values;
  void ** l;
  size_t lSize;
  // size of the sublists to be generated
  size_t subLSize;

  // local values
  struct SubCombinationsGeneratorRecCtx* subListGen;

  // output values

  // contains in input the adress of the list to be filled
  void ** yieldedSubL;
   
};

typedef struct SubCombinationsGeneratorRecCtx SubCombinationsGeneratorRecCtx_t;


short subCombinationsFixedLSizeGenerator_rec (SubCombinationsGeneratorRecCtx_t* ioCoroCtx) {
  crBegin;
  if (ioCoroCtx -> subLSize == 0) {
    crReturn(1);
  } else {
    ioCoroCtx -> subListGen = (SubCombinationsGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationsGeneratorRecCtxHolder);

    //all combinations that contain head of list
    *(ioCoroCtx -> yieldedSubL) = *(ioCoroCtx -> l);

    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l + 1;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize - 1;
    ioCoroCtx -> subListGen -> yieldedSubL = ioCoroCtx -> yieldedSubL + 1;
    ioCoroCtx -> subListGen -> subLSize = ioCoroCtx -> subLSize - 1;

    while (subCombinationsFixedLSizeGenerator_rec(ioCoroCtx ->  subListGen)) {
      crReturn(1);
    }
    NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
    //all combinations that do not contain head of list
    if (ioCoroCtx -> lSize > ioCoroCtx -> subLSize) {
      ioCoroCtx -> subListGen = (SubCombinationsGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationsGeneratorRecCtxHolder);

      ioCoroCtx -> subListGen -> l = ioCoroCtx -> l+1;
      ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize-1;
      ioCoroCtx -> subListGen -> yieldedSubL = ioCoroCtx -> yieldedSubL;
      ioCoroCtx -> subListGen -> subLSize = ioCoroCtx -> subLSize;

      while (subCombinationsFixedLSizeGenerator_rec (ioCoroCtx ->  subListGen)) {
        crReturn(1);
      }
      NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
    }

  }

  crFinish;
  return 0;
}

struct SubCombinationsGeneratorCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values;
  void ** l;
  size_t lSize; 
  size_t maxSize;

  // local values
  size_t i;
  struct SubCombinationsGeneratorRecCtx* subListGen;


  // output values
  size_t yieldedSubLSize;

  // allocated/deallocated automatically at creation/destruction of the context
  void ** yieldedSubL;
   
};
typedef struct SubCombinationsGeneratorCtx SubCombinationsGeneratorCtx_t;

short subCombinationsGenerator(SubCombinationsGeneratorCtx_t* ioCoroCtx) {
  crBegin;

  for (ioCoroCtx -> i=0;
       ioCoroCtx -> i <= ioCoroCtx -> lSize && ioCoroCtx -> i < ioCoroCtx -> maxSize;
       ++(ioCoroCtx -> i)) {

    ioCoroCtx -> yieldedSubLSize = ioCoroCtx -> i;

    ioCoroCtx -> subListGen = (SubCombinationsGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationsGeneratorRecCtxHolder);

    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize;
    ioCoroCtx -> subListGen -> yieldedSubL = ioCoroCtx -> yieldedSubL;
    ioCoroCtx -> subListGen -> subLSize = ioCoroCtx -> i;

    while (subCombinationsFixedLSizeGenerator_rec (ioCoroCtx -> subListGen)) {
      crReturn(1);
    }
    NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
  }


  crFinish;
  return 0;
}


// initializer:
struct SubCombinationsGeneratorCtxInitializer {
  NB_BaseFunctor_t super;
  size_t subLMaxStaticSize;
};
typedef struct SubCombinationsGeneratorCtxInitializer SubCombinationsGeneratorCtxInitializer_t;

void subCombinationsGeneratorCtxInitializer (NB_BaseFunctor_t* iSelf, void* ioCoroCtx) {
  SubCombinationsGeneratorCtxInitializer_t* self = (SubCombinationsGeneratorCtxInitializer_t*) iSelf;
  SubCombinationsGeneratorCtx_t* ctx = (SubCombinationsGeneratorCtx_t*) ioCoroCtx;
  
  ctx -> yieldedSubL = (void **) malloc (sizeof (void*) * self -> subLMaxStaticSize);
}

//cleaner:
struct SubCombinationsGeneratorCtxCleaner {
  NB_BaseFunctor_t super;
};
typedef struct SubCombinationsGeneratorCtxCleaner SubCombinationsGeneratorCtxCleaner_t;


void subCombinationsGeneratorCtxCleaner (NB_BaseFunctor_t* iSelf, void* ioCoroCtx) {
  SubCombinationsGeneratorCtx_t* ctx = (SubCombinationsGeneratorCtx_t*) ioCoroCtx;
  if (ctx -> yieldedSubL != NULL) {
    free (ctx -> yieldedSubL);
  }
}


// ////////////////////////////////////////////////////////////////////////////
// Non-ordered couple of sub-lists generator
// ////////////////////////////////////////////////////////////////////////////


static NB_BaseSLCoroutineCtxHolder_t SubCombinationCouplesGeneratorRecCtxHolder = {0,};
static NB_BaseSLCoroutineCtxHolder_t SubCombinationCouplesGeneratorRec2CtxHolder = {0,};
static NB_BaseSLCoroutineCtxHolder_t SubCombinationCouplesGeneratorCtxHolder = {0,};


struct SubCombinationCouplesGeneratorRecCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values;
  void ** l;
  size_t lSize;

  // size of the first sub-lists in the couple to be generated
  size_t subL1Size;

  // local values
  struct SubCombinationCouplesGeneratorRecCtx* subListGen;

  // output values

  // contains in input the adress of the list to be filled
  void ** yieldedSubL1;
  void ** yieldedSubL2;
   
};

typedef struct SubCombinationCouplesGeneratorRecCtx SubCombinationCouplesGeneratorRecCtx_t;


short subCombinationCouplesFixedLSizeGenerator_rec (SubCombinationCouplesGeneratorRecCtx_t* ioCoroCtx) {
  crBegin;
  if (ioCoroCtx -> subL1Size == 0) {
    size_t i;
    for (i=0;i < ioCoroCtx -> lSize;++i) {
      (ioCoroCtx -> yieldedSubL2)[i] = (ioCoroCtx -> l)[i];
    }
    crReturn(1);
  } else {
    ioCoroCtx -> subListGen = (SubCombinationCouplesGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationCouplesGeneratorRecCtxHolder);

    //all combinations where l1 contains head of list
    *(ioCoroCtx -> yieldedSubL1) = *(ioCoroCtx -> l);

    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l + 1;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize - 1;
    ioCoroCtx -> subListGen -> yieldedSubL1 = ioCoroCtx -> yieldedSubL1 + 1;
    ioCoroCtx -> subListGen -> subL1Size = ioCoroCtx -> subL1Size - 1;
    ioCoroCtx -> subListGen -> yieldedSubL2 = ioCoroCtx -> yieldedSubL2;

    while (subCombinationCouplesFixedLSizeGenerator_rec(ioCoroCtx ->  subListGen)) {
      crReturn(1);
    }
    NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
    //all combinations where l2 contains head of list
    if (ioCoroCtx -> lSize > ioCoroCtx -> subL1Size) {
      ioCoroCtx -> subListGen = (SubCombinationCouplesGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationCouplesGeneratorRecCtxHolder);

      *(ioCoroCtx -> yieldedSubL2) = *(ioCoroCtx -> l);

      ioCoroCtx -> subListGen -> l = ioCoroCtx -> l+1;
      ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize-1;
      ioCoroCtx -> subListGen -> yieldedSubL1 = ioCoroCtx -> yieldedSubL1;
      ioCoroCtx -> subListGen -> subL1Size = ioCoroCtx -> subL1Size;
      ioCoroCtx -> subListGen -> yieldedSubL2 = ioCoroCtx -> yieldedSubL2+1;

      while (subCombinationCouplesFixedLSizeGenerator_rec (ioCoroCtx ->  subListGen)) {
        crReturn(1);
      }
      NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
    }

  }

  crFinish;
  return 0;
}

// same as rec1, but for
// for instance, for [a,b,c,d,e,f], and iSubL1RemSize == 3, does not return both [[a,b,c],[d,e,f]] and  [[d,e,f],[a,b,c]]

struct SubCombinationCouplesGeneratorRec2Ctx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values;
  void ** l;
  size_t lSize;

  // size of the first sub-lists in the couple to be generated
  size_t subL1Size;

  // local values
  struct SubCombinationCouplesGeneratorRecCtx* subListGen;

  // output values

  // contains in input the adress of the list to be filled
  void ** yieldedSubL1;
  void ** yieldedSubL2;
   
};

typedef struct SubCombinationCouplesGeneratorRec2Ctx SubCombinationCouplesGeneratorRec2Ctx_t;

short subCombinationCouplesFixedLSizeGenerator_rec2 (SubCombinationCouplesGeneratorRec2Ctx_t* ioCoroCtx) {
  crBegin;
  ioCoroCtx -> subListGen = (SubCombinationCouplesGeneratorRecCtx_t*) NB_getSLCoroutine(&SubCombinationCouplesGeneratorRecCtxHolder);

  
  if (ioCoroCtx -> subL1Size *2 != ioCoroCtx -> lSize || ioCoroCtx -> lSize == 0) {
    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize;
    ioCoroCtx -> subListGen -> yieldedSubL1 = ioCoroCtx -> yieldedSubL1;
    ioCoroCtx -> subListGen -> subL1Size = ioCoroCtx -> subL1Size;
  } else {
    // ioSubL1 will always hold the sub-lists that contains the first element of L
    *(ioCoroCtx -> yieldedSubL1) = *(ioCoroCtx -> l);

    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l+1;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize-1;
    ioCoroCtx -> subListGen -> yieldedSubL1 = ioCoroCtx -> yieldedSubL1+1;
    ioCoroCtx -> subListGen -> subL1Size = ioCoroCtx -> subL1Size-1;
  }

  ioCoroCtx -> subListGen -> yieldedSubL2 = ioCoroCtx -> yieldedSubL2;

  while (subCombinationCouplesFixedLSizeGenerator_rec(ioCoroCtx ->  subListGen)) {
    crReturn(1);
  }

  NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
  crFinish;
  return 0;
}

struct SubCombinationCouplesGeneratorCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values;
  void ** l;
  size_t lSize;

  // local values
  struct SubCombinationCouplesGeneratorRec2Ctx* subListGen;

  // output values
  size_t i;
  // contains in input the adress of the list to be filled
  // allocated/deallocated automatically at creation/destruction of the context
  size_t yieldedSubL1Size;
  size_t yieldedSubL2Size;

  void ** yieldedSubL1;
  void ** yieldedSubL2;
   
};

typedef struct SubCombinationCouplesGeneratorCtx SubCombinationCouplesGeneratorCtx_t;


short subCombinationCouplesGenerator(SubCombinationCouplesGeneratorCtx_t* ioCoroCtx) {
  crBegin;

  for ((ioCoroCtx -> i) = 0; (ioCoroCtx -> i)*2 <= ioCoroCtx -> lSize;++(ioCoroCtx -> i)) {

    ioCoroCtx -> yieldedSubL1Size = ioCoroCtx -> i;
    ioCoroCtx -> yieldedSubL2Size = ioCoroCtx -> lSize - ioCoroCtx -> i;

    ioCoroCtx -> subListGen = (SubCombinationCouplesGeneratorRec2Ctx_t*) NB_getSLCoroutine(&SubCombinationCouplesGeneratorRec2CtxHolder);

    ioCoroCtx -> subListGen -> l = ioCoroCtx -> l;
    ioCoroCtx -> subListGen -> lSize = ioCoroCtx -> lSize;
    ioCoroCtx -> subListGen -> yieldedSubL1 = ioCoroCtx -> yieldedSubL1;
    ioCoroCtx -> subListGen -> subL1Size = ioCoroCtx -> i;
    ioCoroCtx -> subListGen -> yieldedSubL2 = ioCoroCtx -> yieldedSubL2;

    while (subCombinationCouplesFixedLSizeGenerator_rec2(ioCoroCtx -> subListGen)) {
      crReturn(1);
    }

    NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGen));
  }
  crFinish;
  return 0;
}

// initializer:
struct SubCombinationCouplesGeneratorCtxInitializer {
  NB_BaseFunctor_t super;
  size_t subLMaxStaticSize;
};
typedef struct SubCombinationCouplesGeneratorCtxInitializer SubCombinationCouplesGeneratorCtxInitializer_t;

void subCombinationCouplesGeneratorCtxInitializer (NB_BaseFunctor_t* iSelf, void* ioCoroCtx) {
  SubCombinationCouplesGeneratorCtxInitializer_t* self = (SubCombinationCouplesGeneratorCtxInitializer_t*) iSelf;
  SubCombinationCouplesGeneratorCtx_t* ctx = (SubCombinationCouplesGeneratorCtx_t*) ioCoroCtx;
  
  ctx -> yieldedSubL1 = (void **) malloc (sizeof (void*) * self -> subLMaxStaticSize);
  ctx -> yieldedSubL2 = (void **) malloc (sizeof (void*) * self -> subLMaxStaticSize);
}

//cleaner:
struct SubCombinationCouplesGeneratorCtxCleaner {
  NB_BaseFunctor_t super;
};
typedef struct SubCombinationCouplesGeneratorCtxCleaner SubCombinationCouplesGeneratorCtxCleaner_t;


void subCombinationCouplesGeneratorCtxCleaner (NB_BaseFunctor_t* iSelf, void* ioCoroCtx) {
  SubCombinationCouplesGeneratorCtx_t* ctx = (SubCombinationCouplesGeneratorCtx_t*) ioCoroCtx;
  if (ctx -> yieldedSubL1 != NULL) {
    free (ctx -> yieldedSubL1);
  }

  if (ctx -> yieldedSubL2 != NULL) {
    free (ctx -> yieldedSubL2);
  }
}

// ////////////////////////////////////////////////////////////////////////////
// Basic "Le compte est bon" structures
// ////////////////////////////////////////////////////////////////////////////


struct Node {
  uint_fast64_t value;
  union {
    struct { 
      struct Node * ag;
      struct Node * ad;
      enum {Add, Minus, Mult, Divi}  op;
    } Node;
  } u;
  enum {Number, Node} type;
};

typedef struct Node Node_t;

inline Node_t * allocNode() {
  Node_t *a;
  a = (Node_t *) malloc (sizeof (Node_t));
  a->type=Number;
  return a;  
}

// copy inner values of Node
inline void copyInnerNode (const Node_t* iNode,
                           Node_t* oNode) {
  if (iNode->type == Number) {
    oNode->type = Number;
    oNode->value = iNode->value;
  } else {
    // iNode.type == Node
    oNode->type = Node;
    oNode->value = iNode->value;
    oNode->u.Node.op = iNode->u.Node.op;
  }
}

Node_t * duplicateNode(const Node_t * iNode) {
  Node_t* clonedNode = allocNode ();
  copyInnerNode (iNode,clonedNode);
  
  if (iNode->type == Node) {
    clonedNode->u.Node.ag = duplicateNode (iNode->u.Node.ag);
    clonedNode->u.Node.ad = duplicateNode (iNode->u.Node.ad);
  }
  return clonedNode;
}

void freeNode(Node_t * ioNode) {
  if(ioNode->type == Node) {
    freeNode (ioNode->u.Node.ag);
    freeNode (ioNode->u.Node.ad);
  }
  free(ioNode);
}

// return the priority of top operation of the node
unsigned int opPriority(Node_t * iNode) {
  if(iNode-> type == Node) {
    if(iNode -> u.Node.op == Add || iNode -> u.Node.op == Minus)
      return 1;
    else if(iNode -> u.Node.op == Mult || iNode -> u.Node.op == Divi)
      return 2;
    return 0;
  } else {
    return 100;
  }
}

int opAssociativity(Node_t * iNode) {
  if(iNode-> type == Node) {
    if(iNode -> u.Node.op == Add || iNode -> u.Node.op == Mult)
      return 1;
    else if(iNode -> u.Node.op == Minus || iNode -> u.Node.op == Divi)
      return 0;
    return 0;
  } else {
    return 0;
  }
}


// allocate with malloc a string that represents the expression of the Node
char * stringFromNode (Node_t * iNode) {
  char * c1, *c2, *c;
  unsigned int i1,i2;
  if(iNode -> type == Node) {
    c1=stringFromNode(iNode->u.Node.ag);
    i1=strlen(c1);
    c2=stringFromNode(iNode->u.Node.ad);
    i2=strlen(c2);
    c=(char *) malloc( sizeof(char)*(i1+i2+4+1+1));
    c[0]='\0';

    if(opPriority (iNode->u.Node.ag) < opPriority (iNode)) {
      strcat(c,"(");
      strcat(c,c1);
      strcat(c,")");
    } else
      strcat(c,c1);
      
    if(iNode->u.Node.op == Add)
      strcat(c,"+");
    else if(iNode->u.Node.op == Minus)
      strcat(c,"-");
    else if(iNode->u.Node.op == Mult)
      strcat(c,"*");
    else if(iNode->u.Node.op == Divi)
      strcat(c,"/");
    
    if((!opAssociativity (iNode) && opPriority (iNode->u.Node.ad) <= opPriority (iNode))
       || opPriority (iNode->u.Node.ad) < opPriority (iNode)
       ) {
      strcat(c,"(");
      strcat(c,c2);
      strcat(c,")");
    } else
      strcat(c,c2);
    free(c1);
    free(c2);
  } else {
    char n[500];
    sprintf(n,"%u",(unsigned int) iNode->value);
    c = (char *) malloc (sizeof(char) * (strlen(n) + 1));
    strcpy(c,n);
  }
  return c;
}

// allocate (with malloc) a table of Nodes from a table of int
// of size iLSize
Node_t ** buildNodeVector(unsigned int * iL, size_t iLSize) {
  unsigned int i;
  Node_t ** a;
  a= (Node_t **) malloc (sizeof(Node_t *)* iLSize);
  
  for(i=0;i<iLSize;i++) {
    a[i]=allocNode();
    a[i]->type=Number;
    a[i]->value= iL[i];
  }
  return a;
}

void cleanNodeVector(Node_t ** ioNodes, size_t iNodeSize) {
  unsigned int i;
  
  for(i=0;i<iNodeSize;i++) {
    freeNode (ioNodes[i]);
  }
  free (ioNodes);
}


inline uint_fast64_t valueNode (Node_t * iNodes) {
  return iNodes->value;
}

typedef struct {
  Node_t *node;
  uint_fast64_t delta;
} BestSolution;

inline void tryBestSolution (Node_t *iCurrentTree, unsigned int iTarget, BestSolution* ioBestSolution) {
  uint_fast64_t currentValue = valueNode (iCurrentTree);
  uint_fast64_t delta = ioBestSolution -> delta;
  if (ioBestSolution -> node == NULL ||
      ((currentValue >= iTarget && currentValue - iTarget < ioBestSolution -> delta) ||
       (currentValue < iTarget && iTarget - currentValue < delta))) {
    
    // new bestSolutionFound 
    if (ioBestSolution -> node != NULL) {
      freeNode(ioBestSolution -> node);
    }
    
    char * c=stringFromNode(iCurrentTree);
    printf("Best solution so far: %u = %s \n",(unsigned int) currentValue,c);
    free(c);
    ioBestSolution -> node = duplicateNode(iCurrentTree);

    if (currentValue >= iTarget) {
      ioBestSolution -> delta = currentValue - iTarget;
    } else {
      ioBestSolution -> delta = iTarget - currentValue;
    }    
  }
}


// ////////////////////////////////////////////////////////////////////////////
// Fixed size algo generator
// ////////////////////////////////////////////////////////////////////////////
static NB_BaseSLCoroutineCtxHolder_t LcebFixedSizeGeneratorCtxHolder = {0,};

struct LcebFixedSizeGeneratorCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values:
  Node_t** l;
  size_t lSize;

  // internal variables:
  Node_t newNode;
  SubCombinationCouplesGeneratorCtx_t* coupleGenerator;

  struct LcebFixedSizeGeneratorCtx* elmt1CoroCtx;
  struct LcebFixedSizeGeneratorCtx* elmt2CoroCtx;

  Node_t* elmt1;
  uint_fast64_t val1;

  Node_t* elmt2;
  uint_fast64_t val2;


  // output variables:
  Node_t* yieldedNode;  
};

typedef struct LcebFixedSizeGeneratorCtx LcebFixedSizeGeneratorCtx_t;

// return false when the coroutine ended (the value in yieldedNode must then
// be ignored)
short lcebFixedSizeGenerator(LcebFixedSizeGeneratorCtx_t* ioCoroCtx) {
  crBegin;
  if (ioCoroCtx -> lSize == 1) {
    ioCoroCtx -> yieldedNode = (ioCoroCtx ->l)[0];
    crReturn(1);
  } else {
    ioCoroCtx -> yieldedNode = &(ioCoroCtx -> newNode);
    ioCoroCtx -> yieldedNode -> type = Node;

    // Let's yield all combination of elements of l1 X l2
    // it is generate "the values made of combinations by an operation
    // of the values generated by the couple of lists whose combined
    // total number of elements is L" part of the algorithm described
    // in the "Concept of this algorithm" comment

    ioCoroCtx -> coupleGenerator =
        (SubCombinationCouplesGeneratorCtx_t*) NB_getSLCoroutine (&SubCombinationCouplesGeneratorCtxHolder);
    
    ioCoroCtx -> coupleGenerator -> l = (void **) (ioCoroCtx -> l);
    ioCoroCtx -> coupleGenerator -> lSize = ioCoroCtx -> lSize;

    while (subCombinationCouplesGenerator(ioCoroCtx -> coupleGenerator)) {
      if(ioCoroCtx -> coupleGenerator -> yieldedSubL1Size == 0) {
        continue;
      }
      ioCoroCtx -> elmt1CoroCtx =
        (LcebFixedSizeGeneratorCtx_t*) NB_getSLCoroutine (&LcebFixedSizeGeneratorCtxHolder);
      ioCoroCtx -> elmt1CoroCtx -> l = (Node_t **) (ioCoroCtx -> coupleGenerator -> yieldedSubL1);
      ioCoroCtx -> elmt1CoroCtx -> lSize = ioCoroCtx -> coupleGenerator -> yieldedSubL1Size;
      
      while (lcebFixedSizeGenerator (ioCoroCtx -> elmt1CoroCtx)) {
        ioCoroCtx -> elmt1 = ioCoroCtx -> elmt1CoroCtx -> yieldedNode;
        ioCoroCtx -> val1 = valueNode (ioCoroCtx -> elmt1);
        ioCoroCtx -> newNode.u.Node.ag = ioCoroCtx -> elmt1;

        ioCoroCtx -> elmt2CoroCtx =
          (LcebFixedSizeGeneratorCtx_t*) NB_getSLCoroutine (&LcebFixedSizeGeneratorCtxHolder);
        ioCoroCtx -> elmt2CoroCtx -> l = (Node_t **) (ioCoroCtx ->  coupleGenerator -> yieldedSubL2);
        ioCoroCtx -> elmt2CoroCtx -> lSize = ioCoroCtx -> coupleGenerator -> yieldedSubL2Size;

        while (lcebFixedSizeGenerator (ioCoroCtx -> elmt2CoroCtx)) {
          ioCoroCtx -> elmt2 = ioCoroCtx -> elmt2CoroCtx -> yieldedNode;
          ioCoroCtx -> val2 = valueNode (ioCoroCtx -> elmt2);
          ioCoroCtx -> newNode.u.Node.ad = ioCoroCtx -> elmt2;

            
          if (ioCoroCtx -> val1 > 0 && ioCoroCtx -> val2 > 0) {
            ioCoroCtx -> newNode.value=ioCoroCtx -> val1 + ioCoroCtx -> val2;
            ioCoroCtx -> newNode.u.Node.op = Add;
            crReturn(1);
          }

          if (ioCoroCtx -> val2 > ioCoroCtx -> val1) {
            if (ioCoroCtx -> elmt2 -> type != Node || ioCoroCtx -> elmt2 ->u.Node.op != Add) {
              ioCoroCtx -> newNode.value=ioCoroCtx -> val2 - ioCoroCtx -> val1;
                    
              ioCoroCtx -> newNode.u.Node.ag = ioCoroCtx -> elmt2;
              ioCoroCtx -> newNode.u.Node.ad = ioCoroCtx -> elmt1;
              ioCoroCtx -> newNode.u.Node.op = Minus;
              crReturn(1);
              ioCoroCtx -> newNode.u.Node.ag = ioCoroCtx -> elmt1;
              ioCoroCtx -> newNode.u.Node.ad = ioCoroCtx -> elmt2;
            }
          }
                
          if (ioCoroCtx -> val1 >= ioCoroCtx -> val2) {
            if (ioCoroCtx -> elmt1 -> type != Node || ioCoroCtx -> elmt1 ->u.Node.op != Add) {
              ioCoroCtx -> newNode.value=ioCoroCtx -> val1 - ioCoroCtx -> val2;
                    
              ioCoroCtx -> newNode.u.Node.op = Minus;
              crReturn(1);
            }
          }

          if (ioCoroCtx -> val1 > 1 && ioCoroCtx -> val2 > 1) {
            ioCoroCtx -> newNode.value=ioCoroCtx -> val1 * ioCoroCtx -> val2;
            ioCoroCtx -> newNode.u.Node.op = Mult;
            crReturn(1);
          }    

          if (ioCoroCtx -> elmt2 -> type != Node || ioCoroCtx -> elmt2 ->u.Node.op != Mult) {
            if(ioCoroCtx -> val2 > ioCoroCtx -> val1 && ioCoroCtx -> val1 > 1 && (ioCoroCtx -> val2 % ioCoroCtx -> val1) == 0) {
              ioCoroCtx -> newNode.value=ioCoroCtx -> val2 / ioCoroCtx -> val1;
                    
              ioCoroCtx -> newNode.u.Node.ag = ioCoroCtx -> elmt2;
              ioCoroCtx -> newNode.u.Node.ad = ioCoroCtx -> elmt1;
              ioCoroCtx -> newNode.u.Node.op = Divi;
              crReturn(1);
              ioCoroCtx -> newNode.u.Node.ag = ioCoroCtx -> elmt1;
              ioCoroCtx -> newNode.u.Node.ad = ioCoroCtx -> elmt2;
            }
          }

          if (ioCoroCtx -> elmt1 -> type != Node || ioCoroCtx -> elmt1 ->u.Node.op != Mult) {
            if(ioCoroCtx -> val1 >= ioCoroCtx -> val2 && ioCoroCtx -> val2 > 1 && (ioCoroCtx -> val1 % ioCoroCtx -> val2) == 0) {
              ioCoroCtx -> newNode.value=ioCoroCtx -> val1 / ioCoroCtx -> val2;
                    
              ioCoroCtx -> newNode.u.Node.op = Divi;
              crReturn(1);
            }
          }
        }
        NB_freeSLCoroutineCtx((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> elmt2CoroCtx));
      }
      NB_freeSLCoroutineCtx((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> elmt1CoroCtx));
    }
    NB_freeSLCoroutineCtx((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> coupleGenerator));
  }
  crFinish;
  return 0;
}



// ////////////////////////////////////////////////////////////////////////////
// all sizes algo generator
// ////////////////////////////////////////////////////////////////////////////
static NB_BaseSLCoroutineCtxHolder_t LcebAllSizesGeneratorCtxHolder = {0,};

struct LcebAllSizesGeneratorCtx {
  NB_BaseSLCoroutineCtx_t super;
  
  // input values:
  Node_t** l;
  size_t lSize;

  // internal variables:
  SubCombinationsGeneratorCtx_t* subListGenerator;
  LcebFixedSizeGeneratorCtx_t* elmtGenerator;

  // output variables:
  Node_t* yieldedNode;  
};

typedef struct LcebAllSizesGeneratorCtx LcebAllSizesGeneratorCtx_t;



short lcebAllSizesGenerator(LcebAllSizesGeneratorCtx_t* ioCoroCtx) {
  crBegin;
  // this "algo" calls are used for the 
  // "the values made of N numbers generated by each of its sublists
  // of size N" part of the algorithm described on top of the file
      
  ioCoroCtx -> subListGenerator =
      (SubCombinationsGeneratorCtx_t*) NB_getSLCoroutine (&SubCombinationsGeneratorCtxHolder);


  ioCoroCtx -> subListGenerator -> l = (void**) (ioCoroCtx -> l);
  ioCoroCtx -> subListGenerator -> lSize = ioCoroCtx -> lSize;
  ioCoroCtx -> subListGenerator -> maxSize = ioCoroCtx -> lSize;

  while (subCombinationsGenerator(ioCoroCtx -> subListGenerator)) {
    ioCoroCtx -> elmtGenerator =
      (LcebFixedSizeGeneratorCtx_t*) NB_getSLCoroutine (&LcebFixedSizeGeneratorCtxHolder);
    
    ioCoroCtx -> elmtGenerator -> l = (Node_t **)(ioCoroCtx -> subListGenerator -> yieldedSubL);
    ioCoroCtx -> elmtGenerator -> lSize = ioCoroCtx -> subListGenerator -> yieldedSubLSize;
    
    while (lcebFixedSizeGenerator (ioCoroCtx -> elmtGenerator)) {
      ioCoroCtx -> yieldedNode = ioCoroCtx -> elmtGenerator -> yieldedNode;
      crReturn(1);
    }
    NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> elmtGenerator));
  }

  NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> subListGenerator));

  ioCoroCtx -> elmtGenerator =
    (LcebFixedSizeGeneratorCtx_t*) NB_getSLCoroutine (&LcebFixedSizeGeneratorCtxHolder);
  
  ioCoroCtx -> elmtGenerator -> l = ioCoroCtx -> l;
  ioCoroCtx -> elmtGenerator -> lSize = ioCoroCtx -> lSize;

  while (lcebFixedSizeGenerator (ioCoroCtx -> elmtGenerator)) {
    ioCoroCtx -> yieldedNode = ioCoroCtx -> elmtGenerator -> yieldedNode;
    crReturn(1);
  }
  NB_freeSLCoroutineCtx ((NB_BaseSLCoroutineCtx_t*) (ioCoroCtx -> elmtGenerator));

  crFinish;
  return 0;
}
 


void le_compte_est_bon(unsigned int* iL, size_t iLSize, unsigned int iTarget) {
   
  // initialize pools:
  // SubCombinationsGeneratorRecCtxHolder
  SubCombinationsGeneratorRecCtxHolder.elmtConstructor = NULL;
  SubCombinationsGeneratorRecCtxHolder.elmtDestructor = NULL;
  SubCombinationsGeneratorRecCtxHolder.ctxSize = sizeof (SubCombinationsGeneratorRecCtx_t);

  // SubCombinationsGeneratorCtxHolder
  SubCombinationsGeneratorCtxInitializer_t aSubCombinationsGeneratorCtxInitializer;
  aSubCombinationsGeneratorCtxInitializer.super.run = &subCombinationsGeneratorCtxInitializer;
  aSubCombinationsGeneratorCtxInitializer.subLMaxStaticSize = iLSize;

  SubCombinationsGeneratorCtxCleaner_t aSubCombinationsGeneratorCtxCleaner;
  aSubCombinationsGeneratorCtxCleaner.super.run = &subCombinationsGeneratorCtxCleaner;

  SubCombinationsGeneratorCtxHolder.elmtConstructor = (NB_BaseFunctor_t*) &aSubCombinationsGeneratorCtxInitializer;
  SubCombinationsGeneratorCtxHolder.elmtDestructor = (NB_BaseFunctor_t*) &aSubCombinationsGeneratorCtxCleaner;
  SubCombinationsGeneratorCtxHolder.ctxSize = sizeof (SubCombinationsGeneratorCtx_t);

  // SubCombinationCouplesGeneratorRecCtxHolder
  SubCombinationCouplesGeneratorRecCtxHolder.elmtConstructor = NULL;
  SubCombinationCouplesGeneratorRecCtxHolder.elmtDestructor = NULL;
  SubCombinationCouplesGeneratorRecCtxHolder.ctxSize = sizeof (SubCombinationCouplesGeneratorRecCtx_t);

  // SubCombinationCouplesGeneratorRec2CtxHolder
  SubCombinationCouplesGeneratorRec2CtxHolder.elmtConstructor = NULL;
  SubCombinationCouplesGeneratorRec2CtxHolder.elmtDestructor = NULL;
  SubCombinationCouplesGeneratorRec2CtxHolder.ctxSize = sizeof (SubCombinationCouplesGeneratorRec2Ctx_t);

  // SubCombinationCouplesGeneratorCtxHolder
  SubCombinationCouplesGeneratorCtxInitializer_t aSubCombinationCouplesGeneratorCtxInitializer;
  aSubCombinationCouplesGeneratorCtxInitializer.super.run = &subCombinationCouplesGeneratorCtxInitializer;
  aSubCombinationCouplesGeneratorCtxInitializer.subLMaxStaticSize = iLSize;

  SubCombinationCouplesGeneratorCtxCleaner_t aSubCombinationCouplesGeneratorCtxCleaner;
  aSubCombinationCouplesGeneratorCtxCleaner.super.run = &subCombinationCouplesGeneratorCtxCleaner;

  SubCombinationCouplesGeneratorCtxHolder.elmtConstructor = (NB_BaseFunctor_t*) &aSubCombinationCouplesGeneratorCtxInitializer;
  SubCombinationCouplesGeneratorCtxHolder.elmtDestructor = (NB_BaseFunctor_t*) &aSubCombinationCouplesGeneratorCtxCleaner;
  SubCombinationCouplesGeneratorCtxHolder.ctxSize = sizeof (SubCombinationCouplesGeneratorCtx_t);

  // LcebFixedSizeGeneratorHolder
  LcebFixedSizeGeneratorCtxHolder.elmtConstructor = NULL;
  LcebFixedSizeGeneratorCtxHolder.elmtDestructor = NULL;
  LcebFixedSizeGeneratorCtxHolder.ctxSize = sizeof (LcebFixedSizeGeneratorCtx_t);

  
  // LcebAllSizesGeneratorHolder
  LcebAllSizesGeneratorCtxHolder.elmtConstructor = NULL;
  LcebAllSizesGeneratorCtxHolder.elmtDestructor = NULL;
  LcebAllSizesGeneratorCtxHolder.ctxSize = sizeof (LcebAllSizesGeneratorCtx_t);


  BestSolution bestSolution = {0,};
  Node_t ** l = buildNodeVector(iL, iLSize);


  LcebAllSizesGeneratorCtx_t* elmtGenerator =
      (LcebAllSizesGeneratorCtx_t*) NB_getSLCoroutine (&LcebAllSizesGeneratorCtxHolder);

  elmtGenerator -> l = l;
  elmtGenerator -> lSize = iLSize;

  while (lcebAllSizesGenerator (elmtGenerator)) {
    tryBestSolution (elmtGenerator -> yieldedNode,iTarget,&bestSolution);
    if (bestSolution.node != NULL && bestSolution.delta == 0) {
      break;
    }
  }        
  NB_freeSLCoroutineCtx((NB_BaseSLCoroutineCtx_t*) (elmtGenerator));

  if (bestSolution.node != NULL) {
    if (bestSolution.delta == 0) {
      char * c;
      c=stringFromNode(bestSolution.node);
      printf("%u = %s\n",iTarget,c);
      free(c);
    } else {
      char * c;
      c=stringFromNode(bestSolution.node);
      printf("No Solution found: nearest solution is: %u = %s\n", (unsigned int) valueNode (bestSolution.node),c);
      free(c);
    }
    freeNode (bestSolution.node);
  } else {
    printf("No Solution found\n");
  }

  cleanNodeVector(l, iLSize);

  NB_freeSLCoroutineCtxPool(&SubCombinationsGeneratorRecCtxHolder);
  NB_freeSLCoroutineCtxPool(&SubCombinationsGeneratorCtxHolder);
  NB_freeSLCoroutineCtxPool(&SubCombinationCouplesGeneratorRecCtxHolder);
  NB_freeSLCoroutineCtxPool(&SubCombinationCouplesGeneratorRec2CtxHolder);
  NB_freeSLCoroutineCtxPool(&SubCombinationCouplesGeneratorCtxHolder);
  NB_freeSLCoroutineCtxPool(&LcebFixedSizeGeneratorCtxHolder);
  NB_freeSLCoroutineCtxPool(&LcebAllSizesGeneratorCtxHolder);
}

void message_help(char * prog) {
  printf("%s number1 [number 2 [number 3 ...]] target\n",prog);
}
                 
int main( int argc, char ** argv) {
  int i;
  unsigned int * list;
  unsigned int t,target;

  for(i=0;i<argc;i++)
    if(!strcmp(argv[i],"-h")) {
      message_help(argv[0]);
      return 0;
    }
  
  if(argc<3) {
    message_help(argv[0]);
    return 1;
  } else {
    list = (unsigned int*) malloc (sizeof(unsigned int) * (argc - 2));
    for(i=1;i<argc - 1 ;i++) {
      if(sscanf(argv[i],"%u",&t) != 1) {
        message_help(argv[0]);
        return 1;
      } else {
        list[i-1]=t;
      }
    }
    
    if(sscanf(argv[argc-1],"%u",&target) != 1) {
      message_help(argv[0]);
      return 1;
    }
  }
  le_compte_est_bon(list,argc - 2,target);
  free(list);
  return 0;
}

